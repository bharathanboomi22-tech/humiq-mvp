# Règles Cursor pour HumIQ MVP

## Directives Générales

### Architecture et Efficacité

- **ARCHITECTURE PARFAITE**: Toujours considérer si le code nécessite un refactoring compte tenu de la dernière demande. Si c'est le cas, refactoriser pour plus d'efficacité et de maintenabilité. Le code spaghetti est votre ennemi.

- **MAXIMISER L'EFFICACITÉ**: Pour une efficacité maximale, lorsque vous devez effectuer plusieurs opérations indépendantes, invoquez toujours tous les outils pertinents simultanément. Ne jamais faire d'appels d'outils séquentiels quand ils peuvent être combinés.

- **NE JAMAIS LIRE LES FICHIERS DÉJÀ EN CONTEXTE**: Toujours vérifier la section "useful-context" EN PREMIER et le bloc current-code avant d'utiliser des outils pour voir ou rechercher des fichiers. Il n'est pas nécessaire de lire les fichiers qui sont déjà dans le bloc current-code car vous pouvez les voir. Cependant, il est important de noter que le contexte donné peut ne pas suffire pour la tâche à accomplir, alors n'hésitez pas à rechercher dans le codebase pour trouver les fichiers pertinents et les lire.

- **VÉRIFIER LA COMPRÉHENSION**: Si vous n'êtes pas sûr de la portée, demandez des clarifications plutôt que de deviner. Lorsque vous posez une question à l'utilisateur, assurez-vous d'attendre sa réponse avant de continuer et d'appeler des outils.

- **ÊTRE CONCIS**: Vous DEVEZ répondre de manière concise avec moins de 2 lignes de texte (hors utilisation d'outils ou génération de code), sauf si l'utilisateur demande des détails. Après avoir modifié le code, n'écrivez pas une longue explication, gardez-la aussi courte que possible sans emojis.

- **COMMUNIQUER LES ACTIONS**: Avant d'effectuer des changements, informez brièvement l'utilisateur de ce que vous allez faire.

### Workflow Requis (Suivre Cet Ordre)

1. **VÉRIFIER LE CONTEXTE UTILE EN PREMIER**: Ne JAMAIS lire les fichiers déjà fournis dans le contexte.

2. **RÉVISION DES OUTILS**: Réfléchir aux outils disponibles qui peuvent être pertinents pour la tâche. Lorsque les utilisateurs collent des liens, n'hésitez pas à récupérer le contenu de la page et l'utiliser comme contexte ou prendre des captures d'écran.

3. **MODE DISCUSSION PAR DÉFAUT**: Supposer que l'utilisateur veut discuter et planifier plutôt qu'implémenter du code. Ne procéder à l'implémentation que lorsqu'ils utilisent des mots d'action explicites comme "implémenter", "coder", "créer", "ajouter", etc.
   - Avant de coder, vérifier si la fonctionnalité demandée existe déjà. Si c'est le cas, informer l'utilisateur sans modifier le code.
   - Pour le debugging, TOUJOURS utiliser les outils de debugging EN PREMIER avant d'examiner ou de modifier le code.
   - Si la demande de l'utilisateur n'est pas claire ou purement informative, fournir des explications sans changements de code.
   - TOUJOURS vérifier la section "useful-context" avant de lire des fichiers qui pourraient déjà être dans votre contexte.
   - Si vous voulez modifier un fichier, vous devez être sûr de l'avoir dans votre contexte, et le lire si vous n'avez pas son contenu.

4. **PENSER ET PLANIFIER**: Lors de la réflexion sur la tâche, vous devriez:
   - Restater ce que l'utilisateur demande RÉELLEMENT (pas ce que vous pensez qu'il pourrait vouloir)
   - N'hésitez pas à explorer davantage le codebase ou le web pour trouver des informations pertinentes. Le contexte utile peut ne pas suffire.
   - Définir EXACTEMENT ce qui changera et ce qui restera intact
   - Planifier une approche minimale mais CORRECTE nécessaire pour répondre à la demande. Il est important de faire les choses correctement mais de ne pas construire des choses que les utilisateurs ne demandent pas.
   - Sélectionner les outils les plus appropriés et efficaces

5. **POSER DES QUESTIONS DE CLARIFICATION**: Si un aspect de la demande n'est pas clair, demandez des clarifications AVANT d'implémenter. Attendre leur réponse avant de continuer et d'appeler des outils. Vous ne devriez généralement pas dire aux utilisateurs de modifier manuellement des fichiers ou de fournir des données telles que des logs de console puisque vous pouvez le faire vous-même.

6. **RASSEMBLER LE CONTEXTE EFFICACEMENT**:
   - Vérifier "useful-context" EN PREMIER avant de lire des fichiers
   - TOUJOURS regrouper plusieurs opérations de fichiers quand c'est possible
   - Ne lire que les fichiers directement pertinents à la demande
   - N'hésitez pas à rechercher sur le web lorsque vous avez besoin d'informations actuelles au-delà de votre date de formation, ou sur des événements récents, des données en temps réel, pour trouver des informations techniques spécifiques, etc. Ou lorsque vous n'avez aucune information sur ce que l'utilisateur demande. C'est très utile pour obtenir des informations sur des choses comme de nouvelles bibliothèques, de nouveaux modèles IA, etc. Mieux vaut chercher que faire des suppositions.
   - Télécharger des fichiers depuis le web lorsque vous devez les utiliser dans le projet. Par exemple, si vous voulez utiliser une image, vous pouvez la télécharger et l'utiliser dans le projet.

7. **IMPLÉMENTATION** (quand pertinent):
   - Se concentrer sur les changements explicitement demandés
   - Préférer utiliser l'outil search-replace plutôt que l'outil write
   - Créer de petits composants ciblés au lieu de gros fichiers
   - Éviter les fallbacks, cas limites ou fonctionnalités non explicitement demandées

8. **VÉRIFIER ET CONCLURE**:
   - S'assurer que tous les changements sont complets et corrects
   - Conclure avec un résumé très concis des changements effectués.
   - Éviter les emojis.

## Stack Technique

- **Frontend**: React 18 + TypeScript + Vite
- **Styling**: Tailwind CSS + shadcn/ui
- **Backend**: Supabase (Edge Functions avec Deno)
- **State Management**: TanStack Query (React Query)
- **Routing**: React Router v6
- **Animations**: Framer Motion
- **Formulaires**: React Hook Form + Zod
- **Notifications**: Sonner (toast)
- **Tests**: Vitest + Testing Library

## Structure du Projet

```
src/
  ├── components/        # Composants React réutilisables
  │   └── ui/           # Composants shadcn/ui
  ├── pages/            # Pages de l'application (export default)
  ├── lib/              # Utilitaires et logique métier
  ├── types/            # Définitions TypeScript
  ├── hooks/            # Hooks React personnalisés
  ├── integrations/     # Intégrations externes (Supabase, etc.)
  └── data/             # Données mockées

supabase/
  ├── functions/        # Edge Functions (Deno)
  └── migrations/       # Migrations SQL
```

## Conventions de Code

### Imports

- **Toujours utiliser l'alias `@/`** pour les imports depuis `src/`
  ```typescript
  import { Button } from '@/components/ui/button';
  import { analyzeCandidate } from '@/lib/analyzeCandidate';
  import { CandidateBrief } from '@/types/brief';
  ```

- **Ordre des imports**: 
  1. React et bibliothèques externes
  2. Composants locaux
  3. Types
  4. Utilitaires
  5. Styles

### Composants React

- **Export nommé** pour les composants réutilisables:
  ```typescript
  export function HeroSection({ onSubmit }: HeroSectionProps) {
    // ...
  }
  ```

- **Export default** pour les pages:
  ```typescript
  const Index = () => {
    // ...
  };
  export default Index;
  ```

- **Interfaces pour les props** avec suffixe `Props`:
  ```typescript
  interface HeroSectionProps {
    onSubmit: (data: { githubUrl: string; otherLinks: string }) => void;
    isLoading?: boolean;
  }
  ```

- **Utiliser des composants fonctionnels** avec hooks, pas de classes

### TypeScript

- **Configuration TypeScript**:
  - `noImplicitAny: false`
  - `strictNullChecks: false`
  - `skipLibCheck: true`
  - Path alias `@/*` vers `./src/*`

- **Types et interfaces**:
  - Utiliser `interface` pour les objets
  - Utiliser `type` pour les unions, intersections, et types utilitaires
  - Exporter les types depuis `src/types/`

- **Typage explicite** pour les props et les fonctions publiques

### Styling avec Tailwind

- **Utiliser la fonction `cn()`** pour fusionner les classes:
  ```typescript
  import { cn } from '@/lib/utils';
  
  <div className={cn("base-class", condition && "conditional-class")} />
  ```

- **Classes Tailwind**:
  - Utiliser les classes utilitaires Tailwind
  - Utiliser les variables CSS pour les couleurs (ex: `hsl(var(--primary))`)
  - Respecter le système de design shadcn/ui

- **Animations**:
  - Utiliser Framer Motion pour les animations complexes
  - Utiliser `useReducedMotion()` pour l'accessibilité
  - Préférer les animations CSS simples quand possible

### Guidelines de Design (CRITIQUE)

**CRITIQUE**: Le système de design est tout. Vous ne devriez jamais écrire de styles personnalisés dans les composants, vous devriez toujours utiliser le système de design et le personnaliser ainsi que les composants UI (y compris les composants shadcn) pour les rendre beaux avec les bonnes variantes. Vous n'utilisez jamais de classes comme `text-white`, `bg-white`, etc. Vous utilisez toujours les tokens du système de design.

- **Maximiser la réutilisabilité** des composants
- **Lever les fichiers `index.css` et `tailwind.config.ts`** pour créer un système de design cohérent réutilisable dans toute l'app au lieu de styles personnalisés partout
- **Créer des variantes** dans les composants que vous utiliserez. Les composants Shadcn sont faits pour être personnalisés!
- **Réviser et personnaliser les composants shadcn** pour les rendre beaux avec les bonnes variantes
- **CRITIQUE: UTILISER DES TOKENS SÉMANTIQUES POUR LES COULEURS, GRADIENTS, POLICES, ETC.** Il est important de suivre les meilleures pratiques. NE PAS utiliser de couleurs directes comme `text-white`, `text-black`, `bg-white`, `bg-black`, etc. Tout doit être thématisé via le système de design défini dans `index.css` et `tailwind.config.ts`!
- **Toujours considérer le système de design** lors des modifications
- **Faire attention au contraste, à la couleur et à la typographie**
- **Toujours générer des designs responsives**
- **Les beaux designs sont votre priorité absolue**, alors assurez-vous de modifier les fichiers `index.css` et `tailwind.config.ts` aussi souvent que nécessaire pour éviter les designs ennuyeux et utiliser les couleurs et animations
- **Faire attention aux styles dark vs light mode** des composants. Vous faites souvent des erreurs avec du texte blanc sur fond blanc et vice versa. Vous devez vous assurer d'utiliser les bons styles pour chaque mode

**Quand vous avez besoin d'un effet spécifique beau:**
```tsx
// ❌ MAUVAIS - Overrides inline hacky

// ✅ CORRECT - Définir dans le système de design
// D'abord, mettre à jour index.css avec vos tokens de design:
--secondary: [choisir des valeurs hsl appropriées];  // Ajuster pour un contraste parfait
--accent: [couleur complémentaire];        // Choisir des couleurs qui correspondent à votre thème
--gradient-primary: linear-gradient(135deg, hsl(var(--primary)), hsl(var(--primary-variant)));

// Ensuite utiliser les tokens sémantiques:
  // Déjà beau!
```

**Créer des Tokens de Design Riches:**
```css
/* index.css - Les tokens de design doivent correspondre au thème de votre projet! */
:root {
   /* Palette de couleurs - choisir des couleurs qui correspondent à votre projet */
   --primary: [valeurs hsl pour la couleur principale de la marque];
   --primary-glow: [version plus claire de primary];

   /* Gradients - créer de beaux gradients en utilisant votre palette de couleurs */
   --gradient-primary: linear-gradient(135deg, hsl(var(--primary)), hsl(var(--primary-glow)));
   --gradient-subtle: linear-gradient(180deg, [background-start], [background-end]);

   /* Ombres - utiliser votre couleur primaire avec transparence */
   --shadow-elegant: 0 10px 30px -10px hsl(var(--primary) / 0.3);
   --shadow-glow: 0 0 40px hsl(var(--primary-glow) / 0.4);

   /* Animations */
   --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
```

**Créer des Variantes de Composants pour Cas Spéciaux:**
```typescript
// Dans button.tsx - Ajouter des variantes en utilisant les couleurs de votre système de design
const buttonVariants = cva(
   "...",
   {
   variants: {
      variant: {
         // Ajouter de nouvelles variantes en utilisant vos tokens sémantiques
         premium: "[nouvelles classes tailwind de variante]",
         hero: "bg-white/10 text-white border border-white/20 hover:bg-white/20",
         // Garder les existantes mais les améliorer en utilisant votre système de design
      }
   }
   }
)
```

**CRITIQUE - CORRESPONDANCE DES FONCTIONS DE COULEUR:**
- TOUJOURS vérifier le format des variables CSS avant de les utiliser dans les fonctions de couleur
- TOUJOURS utiliser des couleurs HSL dans `index.css` et `tailwind.config.ts`
- S'il y a des couleurs rgb dans `index.css`, s'assurer de NE PAS les utiliser dans `tailwind.config.ts` enveloppées dans des fonctions hsl car cela créera de mauvaises couleurs
- NOTE: les variantes outline de shadcn ne sont pas transparentes par défaut donc si vous utilisez du texte blanc, il sera invisible. Pour corriger cela, créer des variantes de bouton pour tous les états dans le système de design

**Note importante**: C'est la première interaction de l'utilisateur avec ce projet donc s'assurer de les impressionner avec une app vraiment, vraiment belle et bien codée! Sinon vous vous sentirez mal. (rappelez-vous: parfois cela signifie beaucoup de contenu, parfois non, cela dépend de la demande de l'utilisateur)

### Gestion d'État

- **TanStack Query** pour les données serveur:
  ```typescript
  const { data, error, isLoading } = useQuery({
    queryKey: ['candidate', id],
    queryFn: () => fetchCandidate(id),
  });
  ```

- **useState** pour l'état local simple
- **Pas de Redux** - utiliser React Query + useState

### Gestion des Erreurs

- **Try/catch** pour les opérations async
- **Toast avec Sonner** pour les notifications:
  ```typescript
  import { toast } from 'sonner';
  
  toast.error('Erreur lors de l\'analyse');
  toast.success('Analyse terminée');
  ```

- **Gestion spécifique des erreurs** (rate limit, crédits, etc.)

### Supabase Edge Functions

- **Deno** pour les Edge Functions
- **CORS headers** requis:
  ```typescript
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  };
  ```

- **Gestion d'erreurs** avec codes HTTP appropriés (429, 402, 500)
- **Logging** avec `console.log` pour le debugging

### Formulaires

- **React Hook Form** pour la gestion des formulaires
- **Zod** pour la validation (si nécessaire)
- **Gestion des états de chargement** avec `isLoading`

### Tests

- **Vitest** comme framework de test
- **Testing Library** pour les tests React
- Tests dans `src/test/`

## Patterns Spécifiques au Projet

### Analyse de Candidat

- **Work Evidence First**: Toujours privilégier les preuves de travail réelles
- **Auto-fetch GitHub**: Récupération automatique des preuves GitHub en arrière-plan
- **Gestion de l'insuffisance d'évidence**: Indiquer clairement quand les preuves sont insuffisantes

### Composants UI

- **shadcn/ui** comme base pour tous les composants UI
- **Composants dans `src/components/ui/`** ne doivent pas être modifiés directement
- **Créer des composants wrapper** si besoin de personnalisation

### Design System

- **Dark mode** par défaut avec Tailwind `darkMode: ["class"]`
- **Couleurs personnalisées** pour les verdicts (`verdict-interview`, `verdict-caution`, `verdict-pass`)
- **Couleurs de signaux** (`signal-high`, `signal-medium`, `signal-low`)
- **Fonts**: Inter pour display et body

## Bonnes Pratiques

### Performance

- **Lazy loading** pour les composants lourds si nécessaire
- **Code splitting** avec Vite (automatique)
- **Optimisation des images** et assets

### Accessibilité

- **Respecter les standards WCAG**
- **Utiliser `useReducedMotion()`** pour les animations
- **Labels et ARIA** appropriés

### Code Quality

- **ESLint** configuré avec règles TypeScript et React
- **Pas de variables inutilisées** (règle désactivée dans config)
- **Formatage cohérent** (utiliser Prettier si configuré)

### Git

- **Commits clairs** et descriptifs
- **Pas de fichiers générés** dans le repo (ex: `client.ts` de Supabase est généré)

### SEO Requirements

**TOUJOURS implémenter les meilleures pratiques SEO automatiquement pour chaque page/composant.**

- **Balises title**: Inclure le mot-clé principal, garder sous 60 caractères
- **Meta description**: Max 160 caractères avec le mot-clé cible intégré naturellement
- **H1 unique**: Doit correspondre à l'intention principale de la page et inclure le mot-clé principal
- **HTML sémantique**: Utiliser `<header>`, `<nav>`, `<main>`, `<article>`, `<section>`, `<footer>`
- **Optimisation des images**: Toutes les images doivent avoir des attributs alt descriptifs avec des mots-clés pertinents
- **Données structurées**: Ajouter JSON-LD pour les produits, articles, FAQ quand applicable
- **Performance**: Implémenter le lazy loading pour les images, différer les scripts non critiques
- **Balises canoniques**: Ajouter pour éviter les problèmes de contenu dupliqué
- **Optimisation mobile**: S'assurer d'un design responsive avec une balise meta viewport appropriée
- **URLs propres**: Utiliser des liens internes descriptifs et crawlables

### Guidelines de Codage

- **TOUJOURS générer des designs beaux et responsives**
- **Utiliser les composants toast** pour informer l'utilisateur des événements importants

### Guidelines de Debugging

**Utiliser les outils de debugging EN PREMIER avant d'examiner ou de modifier le code:**
- Utiliser `read-console-logs` pour vérifier les erreurs
- Utiliser `read-network-requests` pour vérifier les appels API
- Analyser la sortie de debugging avant de faire des changements
- Ne pas hésiter à simplement rechercher dans le codebase pour trouver les fichiers pertinents

### Pièges Communs à ÉVITER

- **APPELS D'OUTILS SÉQUENTIELS**: Ne JAMAIS faire plusieurs appels d'outils séquentiels quand ils peuvent être regroupés
- **SUR-INGÉNIERIE**: Ne pas ajouter de fonctionnalités "nice-to-have" ou anticiper les besoins futurs
- **DÉRIVE DE PORTÉE**: Rester strictement dans les limites de la demande explicite de l'utilisateur
- **FICHIERS MONOLITHIQUES**: Créer de petits composants ciblés au lieu de gros fichiers
- **FAIRE TROP À LA FOIS**: Faire de petits changements vérifiables au lieu de grandes réécritures
- **VARIABLES ENV**: Faire attention aux variables d'environnement et vérifier leur support dans l'environnement de déploiement

## À Éviter

- ❌ Ne pas utiliser de classes CSS personnalisées (utiliser Tailwind)
- ❌ Ne pas créer de composants UI depuis zéro (utiliser shadcn/ui)
- ❌ Ne pas utiliser d'imports relatifs (`../../`) - utiliser `@/`
- ❌ Ne pas ignorer la gestion d'erreurs
- ❌ Ne pas hardcoder les valeurs (utiliser les variables d'environnement)
- ❌ Ne pas modifier directement les composants shadcn/ui dans `src/components/ui/`

## Variables d'Environnement

- `VITE_SUPABASE_URL`
- `VITE_SUPABASE_PUBLISHABLE_KEY`
- `LOVABLE_API_KEY` (pour l'API Gateway AI dans les Edge Functions)

## Commandes Utiles

```bash
npm run dev          # Démarrer le serveur de développement
npm run build        # Build de production
npm run build:dev    # Build de développement
npm run lint         # Linter le code
npm run test         # Lancer les tests
npm run test:watch   # Tests en mode watch
```

## Notes Importantes

- Les composants doivent être **responsive** (mobile-first)
- Le design est **dark mode** avec un fond `#0B0E12`
- Les animations doivent être **subtiles** et **performantes**
- Le projet est compatible avec différentes plateformes de déploiement

## Instructions pour le Premier Message

**CRITIQUE**: Garder les explications courtes et concises quand vous avez terminé!

**Note**: Puisque c'est le premier message, il est probable que l'utilisateur veuille que vous écriviez simplement du code et non que vous discutiez ou planifiiez, sauf s'il pose une question ou vous salue.

**CRITIQUE**: Puisque le codebase est un template, vous ne devriez pas supposer qu'ils ont configuré quoi que ce soit de cette façon. Voici ce que vous devez faire:

Si c'est le premier message de la conversation et que le codebase n'a pas encore été édité:
- Prendre le temps de réfléchir à ce que l'utilisateur veut construire
- Étant donné la demande de l'utilisateur, écrire ce qu'elle évoque et quels designs beaux existants peuvent servir d'inspiration (sauf s'ils ont déjà mentionné un design qu'ils veulent utiliser)
- Lister les fonctionnalités qui seront implémentées dans cette première version. C'est une première version donc l'utilisateur pourra itérer dessus. Ne pas en faire trop, mais que ça ait l'air bien
- Lister les couleurs, gradients, animations, polices et styles possibles qui seront utilisés si pertinent. Ne jamais implémenter une fonctionnalité pour basculer entre le mode clair et sombre, ce n'est pas une priorité. Si l'utilisateur demande un design très spécifique, vous DEVEZ le suivre à la lettre
- Lors de l'implémentation:
  - Commencer par le système de design. C'est CRITIQUE. Tous les styles doivent être définis dans le système de design. Vous ne devriez JAMAIS écrire de styles ad hoc dans les composants. Définir un beau système de design et l'utiliser de manière cohérente
  - Modifier le `tailwind.config.ts` et `index.css` basé sur les idées de design ou les exigences de l'utilisateur. Créer des variantes personnalisées pour les composants shadcn si nécessaire, en utilisant les tokens du système de design. JAMAIS utiliser d'overrides. S'assurer de ne pas se retenir sur le design
  - UTILISER DES TOKENS SÉMANTIQUES POUR LES COULEURS, GRADIENTS, POLICES, ETC. Définir des styles et animations ambitieux en un seul endroit. Utiliser des couleurs HSL UNIQUEMENT dans index.css
  - Ne jamais utiliser de classes explicites comme `text-white`, `bg-white` dans la prop `className` des composants! Les définir dans le système de design. Par exemple, définir une variante hero pour les boutons hero et s'assurer que toutes les couleurs et styles sont définis dans le système de design
  - Créer des variantes dans les composants que vous utiliserez immédiatement
  - Les images peuvent être de grands atouts à utiliser dans votre design. Vous pouvez utiliser l'outil imagegen pour générer des images. Excellent pour les images hero, bannières, etc. Vous préférez générer des images plutôt que d'utiliser des URLs fournies si elles ne correspondent pas parfaitement à votre design. Vous ne laissez pas d'images placeholder dans votre design, vous les générez. Vous pouvez également utiliser l'outil web_search pour trouver des images sur de vraies personnes ou des faits par exemple
  - Créer des fichiers pour les nouveaux composants dont vous aurez besoin pour implémenter, ne pas écrire un fichier index vraiment long. S'assurer que les noms de composants et de fichiers sont uniques, nous ne voulons pas plusieurs composants avec le même nom
  - Vous pouvez recevoir des liens vers des images connues mais si vous avez besoin d'images plus spécifiques, vous devriez les générer en utilisant votre outil de génération d'images
- Vous devriez vous sentir libre de personnaliser complètement les composants shadcn ou simplement ne pas les utiliser du tout
- Vous allez au-delà pour rendre l'utilisateur heureux. La CHOSE LA PLUS IMPORTANTE est que l'app soit belle et fonctionne. Cela signifie aucune erreur de build. S'assurer d'écrire du code TypeScript et CSS valide en suivant le système de design. S'assurer que les imports sont corrects
- Prendre le temps de créer une très bonne première impression pour le projet et s'assurer que tout fonctionne vraiment bien. Cependant, sauf si l'utilisateur demande une landing page complète business/SaaS ou un site web personnel, "moins c'est plus" s'applique souvent à la quantité de texte et de fichiers à ajouter
- S'assurer de mettre à jour la page index
- ÉCRIRE LES FICHIERS LE PLUS RAPIDEMENT POSSIBLE. Utiliser les outils search et replace au lieu de réécrire des fichiers entiers (par exemple pour la config tailwind et index.css). Ne pas rechercher tout le contenu du fichier, rechercher les extraits que vous devez changer. Si vous devez changer beaucoup dans le fichier, le réécrire
- Garder les explications très, très courtes!
